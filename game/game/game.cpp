#include "game.h"


/* Added Main menu feature */
Game::Game(int numWorkerThreads, sf::RenderWindow * window, int numLevels, std::string maps) {

	workerPool = new threadPool(numWorkerThreads);

	isMenuActive = false;
	gameActive = false;

	currentLevel = 0;
	totalLevels = numLevels;

	srikanth = new Hero("images_f/sfr.png@images_f/sfl.png@images_f/sbr.png@images_f/sbl.png@images_f/srr.png@images_f/srl.png@images_f/srm.png@images_f/slr.png@images_f/sll.png@images_f/slm.png@","images_f/laserbeam.jpg",sf::Vector2f(15.f,100.f), 100, 10, sf::Keyboard::W, sf::Keyboard::S, sf::Keyboard::A, sf::Keyboard::D, sf::Keyboard::LShift);
	ujjieve = new Hero("images_f/ufr.png@images_f/ufl.png@images_f/ubr.png@images_f/ubl.png@images_f/urr.png@images_f/url.png@images_f/urm.png@images_f/ulr.png@images_f/ull.png@images_f/ulm.png@","images_f/laser.jpg",sf::Vector2f(15.f,0.f), 100, 5, sf::Keyboard::I, sf::Keyboard::K, sf::Keyboard::J, sf::Keyboard::L, sf::Keyboard::RShift);
	mapPaths = maps;

	this->gameWindow = window;
	this->gameWindow->setFramerateLimit(30);
	this->spriteSheet.reserve(20);
	this->sounds.reserve(20);
	this->mainMenu = new Menu(window);  // To create menu
	this->mainMenuSong = new sf::Music();
	this->storySong = new sf::Music();

	std::function<int()> menuJob = std::bind(&Game::loadMenu, this);
	std::function<int()> mapJob = std::bind(&Game::loadMaps, this);// Once game created it starts laoding all the prerequisites.
	this->workerPool->addJob(2,menuJob,mapJob);
	this->workerPool->addJob(1, menuJob);


}
// Method to load the maps 
int Game::loadMaps() {

	int i = 0;
	for (int j = 0; j < totalLevels; j++) {
		
		std::string mapLocation;
		while (mapPaths[i] != '@') mapLocation = mapLocation + mapPaths[i++];
		gameMaps.push_back(Maps(mapLocation, 3840, 3840, 7225));
		i++;
	}

	for (int j = 0; j < totalLevels; j++) {
		gameMaps[j].initialize(0, 0, 1366, 768);
	}

	return 0;
}

// Method to load the menu
int Game::loadMenu() {
	/* MEthod to load the sprites textures for the players enemies etc..*/
	sf::Texture tex;

	std::cout << "Loaded files" << std::endl;
	if (!storySong->openFromFile("music_f/storymusic.ogg")) {
		std::cout << "Failure to load the music";

		return EXIT_FAILURE;
	}



	this->mainMenu->loadMenu();

/*	for (int i = Sprites::mainScreen; i!=Lastsprite; i++) {
		switch(i) {

		case player1:

			if (!tex.loadFromFile("sourcePath")) {
				std::cout << " Error loading" << i;
				return EXIT_FAILURE;
			}
			spriteSheet.push_back(sf::Sprite(tex));
			break;
		case player2:
			if (!tex.loadFromFile("sourcePath")) {
				std::cout << " Error loading" << i;
				return EXIT_FAILURE;
			}
			spriteSheet.push_back(sf::Sprite(tex));
			break;
		case enemy:
			if (!tex.loadFromFile("sourcePath") ){
				std::cout << " Error loading" << i;
				return EXIT_FAILURE;
			}
			spriteSheet.push_back(sf::Sprite(tex));
			break;
		case boss:
			if (!tex.loadFromFile("sourcePath")) {
				std::cout << " Error loading" << i;
				return EXIT_FAILURE;
			}
			spriteSheet.push_back(sf::Sprite(tex));
			break;
		
		}
	}
	sf::SoundBuffer buff;
	for (int i = Sounds::bullet; i!=Lastsound; i++) {
		switch (i) {
		case bullet:
			if (!buff.loadFromFile("bullet.wav")) {
				std::cout << "Error loading sound " << i;
				return EXIT_FAILURE;
			}
			sounds.push_back(sf::Sound(buff));
		case flame:
			if (!buff.loadFromFile("flame.wav")) {
				std::cout << "Error loading sound " << i;
				return EXIT_FAILURE;
			}
			sounds.push_back(sf::Sound(buff));


		}
	}
*/
	return 0;
}
// Method to display the title screen
int Game::displayTitlescreen() {  /* Function to print the title Screen*/

	if (!mainMenuSong->openFromFile("music_f/mainMenuSong2.ogg")) {
		std::cout << "Failure to load the music";

		return EXIT_FAILURE;
	}

	mainMenuSong->play();
	sf::Texture tex;
	sf::Sprite sp;
	tex.setSmooth(true);
	if (!tex.loadFromFile("images_f/openingimage1.png")) {
		std::cout << "Failure";
		return EXIT_FAILURE;
	}

	
	sp.setTexture(tex);

	this->gameWindow->draw(sp);
	this->gameWindow->display();
	return 0;

}
// Method to display the story
int Game::displayStory() {

	mainMenuSong->pause();
	storySong->play();

	gameWindow->setActive(true);

	std::string image = "images_f/1story.png@images_f/2story.png@images_f/3story.png@images_f/4story.png@";
	std::string waitTime = "6@6@5@4@";

	Image_player img_list(image,waitTime, 4);

	img_list.image_display_function(gameWindow);
	std::this_thread::sleep_for(std::chrono::seconds(2));
	storySong->stop();
	gameWindow->setActive(false);
	return 0;

}
// Method to handle the events generated by key press etc.
void Game::handleEvents() {

	while (gameWindow->pollEvent(event)) {
		switch (event.type) {
		case sf::Event::Closed:
			gameWindow->close();
	
			break;
		
		
		case sf::Event::KeyPressed:
		//	iskey = false;
			std::cout << "keypressed\n";
			break;

		case sf::Event::KeyReleased:
		//	iskey = true;
			std::cout << "keyreleased\n";
			if (event.key.code == sf::Keyboard::Escape) {
/*				if (isPlaymode) {
					gameWindow->setActive(false);
					std::function<int()> job = std::bind(&Menu::displayMenu, this->mainMenu);
					workerPool->addJob(job);

				}
*/				break;
			}
			else if (event.key.code == sf::Keyboard::Return) {
				if (isMenuActive == true) { // Condition for selecting the menu if menu is active
					std::cout << "Menu no." << mainMenu->menuSelected << std::endl;
					std::function<int()> job;
					switch (mainMenu->menuSelected) {
					case 0:
						mainMenuSong->pause();
						gameWindow->setActive(false);
						isMenuActive = false;
						job = std::bind(&Game::displayStory, this);
						workerPool->addJob(1, job);
						break;

					case 1:
						std::cout << "Game started let's play" << std::endl;
						gameActive = true;
						mainMenuSong->pause();
						gameWindow->setActive(true);
						ujjieve->initialize();
						srikanth->initialize();
						gameWindow->clear();

						break;
					case 2:
						gameWindow->clear(sf::Color::Black);
						gameWindow->close();
						break;
					}
				}
				else { // Condition for starting the game after the story is displayd
					std::cout << "Game started let's play" << std::endl;
					gameActive = true;
					gameWindow->setActive(true);
					ujjieve->initialize();
					srikanth->initialize();
					gameWindow->clear();


				}
			
			}
			
			else if (event.key.code == sf::Keyboard::Up && isMenuActive) {
				gameWindow->setActive(true);
				mainMenu->moveUp();
				break;
			}
			else if (event.key.code == sf::Keyboard::Down && isMenuActive) {
				gameWindow->setActive(true);
				mainMenu->moveDown();
				break;
			}

			else if (event.key.code == sf::Keyboard::Space && !gameActive) {
				mainMenuSong->pause();
				mainMenuSong->play();
				isMenuActive = true;
				gameWindow->setActive(false);
				std::function<int()> job = std::bind(&Menu::displayMenu,this->mainMenu);
				//workerPool->addJob(job);
				std::function<int()> hero1Job = std::bind(&Player::loadFiles, this->srikanth);
				std::function<int()> hero2Job = std::bind(&Player::loadFiles, this->ujjieve);
				workerPool->addJob(3,job, hero1Job, hero2Job);

				break;
			}

		}
	}
}
// Method to update the players position health etc.
int Game::playersUpdate() {
	//if (!iskey) return 0;
	srikanth->update(this->gameWindow->getSize());
	ujjieve->update(this->gameWindow->getSize());
	return 0;
}
// Method to update the map
int Game::mapUpdate() {
	return 0;

}
// Method to render the map
void Game::mapRender() {

}
// Method to render the players
void Game::playerRender() {
	srikanth->draw(this->gameWindow);
	ujjieve->draw(this->gameWindow);
}

// Method for updation 
void Game::update() {
	mapUpdate();
	playersUpdate();
//	std::function<int()> mapJob = std::bind(&Game::mapUpdate, this);
//	std::function<int()> playerJob = std::bind(&Game::playersUpdate, this);
//	workerPool->addJob(2, mapJob, playerJob);

}

// Method for rendering purposes
void Game::render() {
	gameWindow->clear();
	mapRender();
	playerRender();
	gameWindow->display();
}

Game::~Game() {

}

